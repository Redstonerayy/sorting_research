\documentclass[25pt, a0paper, portrait]{tikzposter}

% package
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{bchart}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{setspace}

% language
\usepackage[german]{babel}
\usetikzlibrary{babel}

% font to helvec
\usepackage{unicode-math}
\usepackage{fontspec}
\setmainfont{Arial}

% custom theming
% https://github.com/debjyoti385/tikzposter

% define colorstyle
\definecolorstyle{Rodenland}{
    % Define default colors
    % PurpleGrayBlue
    \definecolor{colorOne}{HTML}{AE0D45}
    \definecolor{colorTwo}{HTML}{7F8897}
    \definecolor{colorThree}{HTML}{C8512D}
}{
     % Background Colors
    \colorlet{backgroundcolor}{white}
    \colorlet{framecolor}{white}
    % Title Colors
    \colorlet{titlebgcolor}{colorOne}
    \colorlet{titlefgcolor}{white}
    % Block Colors
    \colorlet{blocktitlebgcolor}{colorTwo}
    \colorlet{blocktitlefgcolor}{colorOne}
    \colorlet{blockbodybgcolor}{white}
    \colorlet{blockbodyfgcolor}{black}
    % Innerblock Colors
    \colorlet{innerblocktitlebgcolor}{colorThree}
    \colorlet{innerblocktitlefgcolor}{white}
    \colorlet{innerblockbodybgcolor}{white}
    \colorlet{innerblockbodyfgcolor}{black}
    % Note colors
    \colorlet{notefgcolor}{black}
    \colorlet{notebgcolor}{colorOne!20!white}
    \colorlet{notefrcolor}{colorOne!00!white}
 }

 \definetitlestyle{Default}{
    width=500mm, roundedcorners=30, linewidth=0.4cm, innersep=1cm,
    titletotopverticalspace=15mm, titletoblockverticalspace=20mm,
    titlegraphictotitledistance=10pt, titletextscale=1
}{
    \begin{scope}[line width=\titlelinewidth, rounded corners=\titleroundedcorners]
        \draw[color=framecolor, fill=titlebgcolor]%
        (\titleposleft,\titleposbottom) rectangle (\titleposright,\titlepostop);
    \end{scope}
}

 % define block stzle
 \defineblockstyle{Minimal}{
    titlewidthscale=1, bodywidthscale=1, titleleft,
    titleoffsetx=0pt, titleoffsety=0pt, bodyoffsetx=0pt, bodyoffsety=0pt,
    bodyverticalshift=0pt, roundedcorners=0, linewidth=0.2cm,
    titleinnersep=1cm, bodyinnersep=1cm
}{
    \begin{scope}[line width=\blocklinewidth, rounded corners=\blockroundedcorners]
       \ifBlockHasTitle %
           \draw[draw=none]%, fill=blockbodybgcolor]
               (blockbody.south west) rectangle (blocktitle.north east);
        %    \draw[color=blocktitlebgcolor, loosely dashed]
        %        (blocktitle.south west) -- (blocktitle.south east);%
       \else
             \draw[draw=none]%, fill=blockbodybgcolor]
                 (blockbody.south west) rectangle (blockbody.north east);
        \fi
    \end{scope}
}

% inner block style
\defineinnerblockstyle{Default}{
    titlewidthscale=1, bodywidthscale=1, titlecenter,
    titleoffsetx=0pt, titleoffsety=0pt, bodyoffsetx=0pt, bodyoffsety=0pt,
    bodyverticalshift=0pt, roundedcorners=20, linewidth=4pt,
    titleinnersep=12pt, bodyinnersep=12pt
}{
    \begin{scope}[line width=\innerblocklinewidth, rounded
      corners=\innerblockroundedcorners, solid]
        \ifInnerblockHasTitle %
           \draw[color=innerblocktitlebgcolor, fill=innerblocktitlebgcolor]
           (innerblockbody.south west) rectangle (innerblocktitle.north east);
           \draw[color=innerblocktitlebgcolor, fill=innerblockbodybgcolor]
           (innerblockbody.south west) rectangle (innerblockbody.north east);
        \else
           \draw[color=innerblocktitlebgcolor, fill=innerblockbodybgcolor]
           (innerblockbody.south west) rectangle (innerblockbody.north east);
        \fi
    \end{scope}
}

 % define layout theme
\definelayouttheme{PosterAnton}{
    \usecolorstyle{Rodenland}
    \usebackgroundstyle{Default}
    \usetitlestyle{Default}
    \useblockstyle{Minimal}
    \useinnerblockstyle{Default}
    \usenotestyle{Default}
}

% Theme Simple
\usetheme{PosterAnton}

% change background color of poster
\colorlet{backgroundcolor}{white}

% remove tikzposter notice at bottom
\tikzposterlatexaffectionproofoff

\settitle{ \centering \vbox{
    \@titlegraphic \\[\TP@titlegraphictotitledistance] \centering
    \color{titlefgcolor} {\bfseries \Huge \sc \textbf{\@title} \par}
    \vspace*{1em}
    {\huge \textbf{\@author} \par} \vspace*{1em} {\LARGE \@institute}
}}

% formatting
\setlength\columnsep{3cm}
\setstretch{1.25}

% main document
\begin{document}

% title
\title{supersonic algorithms}
\author{Anton Rodenwald (18), Schillerschule Hannover}

\maketitle

% content

\block{Quicksort Implementationen in Python mit verschiedenen Optimierungen und Vergleich mit C++}{
    \begin{multicols}{2}
        
        \Large
        Das Diagramm zeigt die Ausführungzungszeit meiner verschiedenen Implementationen des 
        Sortieralgorithmus Quicksort in den Programmiersprachen Python und C++,
        die ich eine zuvor generierte, unsortierte Liste aus
        10 Millionen zufälligen Ganzzahlen sortieren ließ.
        Zusätzlich sind noch die spracheigenen Sortierfunktionen als Vergleichswerte
        aufgeführt.
        Meine Erste Version (3) brauchte ca. 41 Sekunden zur Sortierung.
        Überraschenderweise brauchten einige Versionen mit Cython und NumPy
        (1, 2) teils länger, was ich mir nicht erklären kann. 
        Als ich dann Cython zur statischen Typisierung nutzte, zeigte sich ein
        guter Zuwachs an Performance (5), wobei weitere Optimierungen mit Cython (4)
        keinen Effekt hatten.
        Bei Versionen mit Numba (6, 8) gab es einen noch größeren Zuwachs an Geschwindigkeit, der
        sich durch Nutzung eines NumPy Arrays verstärken ließ (8).
        Meine Version mit Numba und NumPy (8) war sogar schneller als die normale
        Sortierfunktion für Python Listen (7).
        Einzig schneller waren nur einige C/C++ Versionen (9, 10, 11) und die
        standardmäßige Sortierfunktion für NumPy Arrays, was ich so erwartet hatte.
        Es zeigt sich, dass NumPy eine genauso schnelle Sortierung wie C++ ermöglicht.
        Dies überraschte mich sehr, weil es meiner Hypothese und den Foren-Beiträgen,
        die ich gelesen hatte, komplett widersprach.
        
        \columnbreak
        \begin{tikzfigure}[]
            \hspace{-5cm}\begin{bchart}[min=0, max=80, scale=3.7]
                \bcbar[label=1, text=Quicksort mit NumPy Array]{72.231}
                \smallskip
                \bcbar[label=2, text=Quicksort mit Cython kompiliert]{52.808}
                \smallskip
                \bcbar[label=3, text=Quicksort mit Python Liste]{40.493}
                \smallskip
                \bcbar[label=4, text=\hspace{12cm}Quicksort mit Cython (alle Optimierungen)]{14.717}
                \smallskip
                \bcbar[label=5, text=\hspace{12cm}Quicksort mit Cython (statische Typisierung)]{14.403}
                \smallskip
                \bcbar[label=7, text=\hspace{12cm}Quicksort mit Numba und numba.typed list]{9.744}
                \smallskip
                \bcbar[label=7, text=\hspace{7cm}list.sort() mit Python Liste]{5.314}
                \smallskip
                \bcbar[label=8, text=\hspace{7cm}Quicksort mit Numba und NumPy Array]{1.805}
                \smallskip
                \bcbar[label=9, text=\hspace{7cm}C++ Quicksort]{1.051}
                \smallskip
                \bcbar[label=12, text=\hspace{7cm}C Quicksort aufgerufen mit CTypes]{1.035}
                \smallskip
                \bcbar[label=11, text=\hspace{7cm}C++ Standard Quicksort (std::sort)]{0.909}
                \smallskip
                \bcbar[label=12, text=\hspace{7cm}list.sort() mit NumPy Array]{0.894}
                \smallskip
                \bcxlabel{\bf{Ausführungszeit in Sekunden}}
            \end{bchart}
        \end{tikzfigure}
    \end{multicols}
}

\block{Quicksort Implementationen in weiteren Sprachen im Vergleich}{
    \begin{multicols}{2}

    \Large
    \begin{tikzfigure}[]
        \begin{bchart}[min=0, max=15, scale=3.5]
            \bcbar[label=1, text=Quicksort Lua]{11.528}
            \smallskip
            \bcbar[label=2, text=Lua table.sort (Standardsortierung)]{11.035}
            \smallskip
            \bcbar[label=3, text=\hspace{14cm}Java Collection.sort (Standardsortierung)]{5.016}
            \smallskip
            \bcbar[label=4, text=\hspace{14cm}Quicksort Javascript]{3.167}
            \smallskip
            \bcbar[label=5, text=\hspace{14cm}Quicksort Java]{2.828}
            \smallskip
            \bcbar[label=6, text=\hspace{7cm}Quicksort Julia und Julia sort (Standardsortierung)]{1.374}
            \smallskip
            \bcbar[label=7, text=\hspace{7cm}Javascript array.sort (Standardsortierung)]{1.159}
            \smallskip
            \bcbar[label=8, text=\hspace{7cm}Quicksort Go (7 Millionen Zahlen)]{0.919}
            \smallskip
            \bcxlabel{\bf{Ausführungszeit in Sekunden}}
        \end{bchart}
    \end{tikzfigure}

    \columnbreak
    
    \Large
    Auch interessierten mich Implementationen von Quicksort in anderen Sprachen, wo
    ich aber aufgrund meines limitierten Wissens in diesen Sprachen keine Optimierungen
    vornahm.
    Es fällt direkt auf, dass Lua (1, 2) sowohl mit der Quicksort als auch mit der
    standardmäßigen Sortierung im Vergleich sehr schlecht abschneidet.
    Darauf folgt die standardmäßige Sortierung in Java (3).
    Diese ist überraschenderweise langsamer als meine Quicksort Implementation in Java (5).
    Zwischen diesen beiden liegt meine Quicksort in Javascript (4).
    Darauf folgt dann Julia (6), wo meine eigene Quicksort fast genauso schnell war wie
    die standardmäßige Sortierfunktion.
    Einzig schneller sind nur die standardmäßige Sortierfunktion in Javascript (7) und meine
    Quicksort Implementation in Go (8), wobei die Versionen in Go nur 7 Millionen Zahlen sortiert
    aufgrund von Implementationsschwierigkeiten.

    \end{multicols}
}

\block{C++ Radixsort Implementationen}{
    \begin{multicols}{2}

    \Large
    Um eine niedrig möglichste Zeit zu erreichen schaute ich mir noch die Radixsort als anderen Sortieralgorithmus
    an, die allerdings nicht direkt mit der Quicksort vergleichbar ist.
    Implementationen dieser brauchten zuerst 2.269 Sekunden (1),
    doch ich konnte die Performance noch steigern (2, 3) und die Quicksort überholen.
    Dies zeigte mir, dass korrekte Implementation und Wahl des Algorithmuvon eine wichtige Rolle spielen.
    Auf die resultierende Frage, wieso die Radixsort nicht häufiger genutzt wird, fand ich bisher
    noch keine Antwort.
    
    \columnbreak

    \begin{tikzfigure}[]
        \begin{bchart}[min=0, max=2.5, scale=3.7]
            \bcbar[label=1, text=Radixsort mit Basis 10 (Countingsort)]{2.269}
            \smallskip
            \bcbar[label=2, text=\hspace{7cm}Radixsort mit Basis 256 (Bytesort)]{0.244}
            \smallskip
            \bcbar[label=3, text=\hspace{7cm}Radixsort mit Basis 256 (Bytesort) und AVX2]{0.240}
            \smallskip
            \bcxlabel{\bf{Ausführungszeit in Sekunden}}
        \end{bchart}
    \end{tikzfigure}

    \end{multicols}
}

\end{document}
