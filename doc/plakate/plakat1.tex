\documentclass[25pt, a0paper, portrait]{tikzposter}

% package
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{bchart}
\usepackage{tikz}
\usepackage{multicol}

% language
\usepackage[german]{babel}
\usetikzlibrary{babel}

% font to helvec
% \usepackage{unicode-math}
% \usepackage{fontspec}
% \setmainfont{Arial}

% custom theming
% https://github.com/debjyoti385/tikzposter

% define colorstyle
\definecolorstyle{Rodenland}{
    % Define default colors
    % PurpleGrayBlue
    \definecolor{colorOne}{HTML}{AE0D45}
    \definecolor{colorTwo}{HTML}{7F8897}
    \definecolor{colorThree}{HTML}{C8512D}
}{
     % Background Colors
    \colorlet{backgroundcolor}{white}
    \colorlet{framecolor}{white}
    % Title Colors
    \colorlet{titlebgcolor}{colorOne}
    \colorlet{titlefgcolor}{white}
    % Block Colors
    \colorlet{blocktitlebgcolor}{colorTwo}
    \colorlet{blocktitlefgcolor}{colorOne}
    \colorlet{blockbodybgcolor}{white}
    \colorlet{blockbodyfgcolor}{black}
    % Innerblock Colors
    \colorlet{innerblocktitlebgcolor}{colorThree}
    \colorlet{innerblocktitlefgcolor}{white}
    \colorlet{innerblockbodybgcolor}{white}
    \colorlet{innerblockbodyfgcolor}{black}
    % Note colors
    \colorlet{notefgcolor}{black}
    \colorlet{notebgcolor}{colorOne!20!white}
    \colorlet{notefrcolor}{colorOne!00!white}
 }

 \definetitlestyle{Default}{
    width=500mm, roundedcorners=30, linewidth=0.4cm, innersep=1cm,
    titletotopverticalspace=15mm, titletoblockverticalspace=20mm,
    titlegraphictotitledistance=10pt, titletextscale=1
}{
    \begin{scope}[line width=\titlelinewidth, rounded corners=\titleroundedcorners]
        \draw[color=framecolor, fill=titlebgcolor]%
        (\titleposleft,\titleposbottom) rectangle (\titleposright,\titlepostop);
    \end{scope}
}

 % define block stzle
 \defineblockstyle{Minimal}{
    titlewidthscale=1, bodywidthscale=1, titleleft,
    titleoffsetx=0pt, titleoffsety=0pt, bodyoffsetx=0pt, bodyoffsety=0pt,
    bodyverticalshift=0pt, roundedcorners=0, linewidth=0.2cm,
    titleinnersep=1cm, bodyinnersep=1cm
}{
    \begin{scope}[line width=\blocklinewidth, rounded corners=\blockroundedcorners]
       \ifBlockHasTitle %
           \draw[draw=none]%, fill=blockbodybgcolor]
               (blockbody.south west) rectangle (blocktitle.north east);
        %    \draw[color=blocktitlebgcolor, loosely dashed]
        %        (blocktitle.south west) -- (blocktitle.south east);%
       \else
             \draw[draw=none]%, fill=blockbodybgcolor]
                 (blockbody.south west) rectangle (blockbody.north east);
        \fi
    \end{scope}
}

% inner block style
\defineinnerblockstyle{Default}{
    titlewidthscale=1, bodywidthscale=1, titlecenter,
    titleoffsetx=0pt, titleoffsety=0pt, bodyoffsetx=0pt, bodyoffsety=0pt,
    bodyverticalshift=0pt, roundedcorners=20, linewidth=4pt,
    titleinnersep=12pt, bodyinnersep=12pt
}{
    \begin{scope}[line width=\innerblocklinewidth, rounded
      corners=\innerblockroundedcorners, solid]
        \ifInnerblockHasTitle %
           \draw[color=innerblocktitlebgcolor, fill=innerblocktitlebgcolor]
           (innerblockbody.south west) rectangle (innerblocktitle.north east);
           \draw[color=innerblocktitlebgcolor, fill=innerblockbodybgcolor]
           (innerblockbody.south west) rectangle (innerblockbody.north east);
        \else
           \draw[color=innerblocktitlebgcolor, fill=innerblockbodybgcolor]
           (innerblockbody.south west) rectangle (innerblockbody.north east);
        \fi
    \end{scope}
}

 % define layout theme
\definelayouttheme{PosterAnton}{
    \usecolorstyle{Rodenland}
    \usebackgroundstyle{Default}
    \usetitlestyle{Default}
    \useblockstyle{Minimal}
    \useinnerblockstyle{Default}
    \usenotestyle{Default}
}

% Theme Simple
\usetheme{PosterAnton}

% change background color of poster
\colorlet{backgroundcolor}{white}

% remove tikzposter notice at bottom
\tikzposterlatexaffectionproofoff

\settitle{ \centering \vbox{
    \@titlegraphic \\[\TP@titlegraphictotitledistance] \centering
    \color{titlefgcolor} {\bfseries \Huge \sc \textbf{\@title} \par}
    \vspace*{1em}
    {\huge \textbf{\@author} \par} \vspace*{1em} {\LARGE \@institute}
}}

% main document
% \subsection{Quicksort Implementationen in Python mit verschiedenen Optimierungen und Vergleich mit C++}
\begin{document}

% title
\title{Supersonic Algorithms}
\author{Anton Rodenwald (18), Schillerschule Hannover}

\maketitle

% content
% \block{Quicksort Implementationen in Python mit verschiedenen Optimierungen und Vergleich mit C++}{}

\block{Quicksort Implementationen in Python mit verschiedenen Optimierungen und Vergleich mit C++}{
    \begin{multicols}{2}
        
        \Large 
        In diesem Diagramm sind meine verschiedenen Versionen der Quicksort in Python,
        die standardmäßig verfügbaren Sortierfunktionen von Python und C++
        sowie eine in C++ implementierte Quicksort zu sehen.
        Alle diese Versionen ließ ich eine vorher generierte, unsortierte Liste aus
        10 Millionen zufälligen Zahlen sortieren.
        Meine im Informatikunterricht entwickelte Version (3) brauchte ca. 41 Sekunden
        zur Sortierung. Überraschend war für mich dann, dass Versionen mit Cython und NumPy
        (1, 2) teils länger brauchten. Dies hatte ich nicht erwartet. Ich ging eigentlich davon aus,
        dass es nur positive Veränderungen geben würde, also meine Implementationen nur schneller werden
        würden. Als ich dann Cython zur statischen Typisierung nutzte, zeigte sich ein
        guter Zuwachs an Performance (5). Weitere Optimierungen mit Cython (4)
        schienen aber keinen Effekt zu haben, was mich wunderte.
        Da Cython vor der Ausführung kompiliert wird, hatte ich eigentlich mit einer
        größeren Geschwindigkeitserhöhung gerechnet, was nicht der Fall war.
        Ungefähr 4.5x schneller war meine Version mit Numba und der Numba Typed List (6).
        Nutzte ich Numba nun in Kombination mit einem NumPy Array (8), so erhöhte sich
        die Geschwindigkeit nochmal um ein Vielfaches.
        Meine Version mit Numba und NumPy (8) war sogar schneller als die normale
        Sortierfunktion für Python Listen (7). Dies bestätigte meine Erwartungen,
        dass NumPy und Numba einen großen Boost in Performance bringen,
        doch es überraschte mich, dass dieser so groß war.
        Einzig schneller waren nur einige C/C++ Versionen (9, 10, 11) und die
        standardmäßige Sortierfunktion für NumPy Arrays, was ich so erwartet hatte.
        Meine in C++ implementierte Quicksort (9) war dabei ähnlich schnell
        wie die standardmäßige C++ Sortierfunktion (11).
        Wichtig zu erwähnen zur Version mit CTypes (10) ist, dass die Konvertierung
        einer Python Liste in ein für C verständliches Format auch nochmal ca. 2 Sekunden
        Zeit kostete.
        Es zeigt sich, dass NumPy eine genauso schnelle Sortierung wie C++ ermöglicht.
        Dies überraschte mich sehr, weil es meiner Hypothese und den Foren-Beiträgen,
        die ich gelesen hatte, komplett widersprach.
        Ich fragte mich, wie sich die Versionen 3 und 12 unterschieden.
        Um mir diese Frage zu beantworten stellte ich einige Überlegungen an,
        die ich später diskutieren werde.
        
        \columnbreak
        \begin{tikzfigure}[]
            \hspace{-5cm}\begin{bchart}[min=0, max=80, scale=4]
                \bcbar[label=1, text=Quicksort mit NumPy Array]{72.231}
                \smallskip
                \bcbar[label=2, text=Quicksort mit Cython kompiliert]{52.808}
                \smallskip
                \bcbar[label=3, text=Quicksort mit Python Liste]{40.493}
                \smallskip
                \bcbar[label=4, text=\hspace{12cm}Quicksort mit Cython (alle Optimierungen)]{14.717}
                \smallskip
                \bcbar[label=5, text=\hspace{12cm}Quicksort mit Cython (statische Typisierung)]{14.403}
                \smallskip
                \bcbar[label=7, text=\hspace{12cm}Quicksort mit Numba und numba.typed list]{9.744}
                \smallskip
                \bcbar[label=7, text=\hspace{7cm}list.sort() mit Python Liste]{5.314}
                \smallskip
                \bcbar[label=8, text=\hspace{7cm}Quicksort mit Numba und NumPy Array]{1.805}
                \smallskip
                \bcbar[label=9, text=\hspace{7cm}C++ Quicksort]{1.051}
                \smallskip
                \bcbar[label=12, text=\hspace{7cm}C Quicksort aufgerufen mit CTypes]{1.035}
                \smallskip
                \bcbar[label=11, text=\hspace{7cm}C++ Standard Quicksort (std::sort)]{0.909}
                \smallskip
                \bcbar[label=12, text=\hspace{7cm}list.sort() mit NumPy Array]{0.894}
                \smallskip
                \bcxlabel{\bf{Ausführungszeit in Sekunden}}
            \end{bchart}
        \end{tikzfigure}
    \end{multicols}
}

\block{Quicksort Implementationen in weiteren Sprachen im Vergleich}{
    \begin{multicols}{2}

    \begin{tikzfigure}[]
        \begin{bchart}[min=0, max=15, scale=4]
            \bcbar[label=1, text=Quicksort Lua]{11.528}
            \smallskip
            \bcbar[label=2, text=Lua table.sort (Standardsortierung)]{11.035}
            \smallskip
            \bcbar[label=3, text=\hspace{14cm}Java Collection.sort (Standardsortierung)]{5.016}
            \smallskip
            \bcbar[label=4, text=\hspace{14cm}Quicksort Javascript]{3.167}
            \smallskip
            \bcbar[label=5, text=\hspace{14cm}Quicksort Java]{2.828}
            \smallskip
            \bcbar[label=6, text=\hspace{7cm}Quicksort Julia und Julia sort (Standardsortierung)]{1.374}
            \smallskip
            \bcbar[label=7, text=\hspace{7cm}Javascript array.sort (Standardsortierung)]{1.159}
            \smallskip
            \bcbar[label=8, text=\hspace{7cm}Quicksort Go (7 Millionen Zahlen)]{0.919}
            \smallskip
            \bcxlabel{\bf{Ausführungszeit in Sekunden}}
        \end{bchart}
    \end{tikzfigure}

    \columnbreak
    
    \Large
    Neben C++ und Python interessierte mich auch, wie schnell das Sortieren mit
    einer Implementation der Quicksort in anderen Sprachen möglich ist.
    Ich nahm dabei aufgrund meines limitierten Wissens in diesen Sprachen keine Optimierungen
    vor. Dies tat ich auch, weil mich interessierte, wie schnell die nativen
    Implementationen der Quicksort in diesen ist.
    Es fällt direkt auf, dass Lua (1, 2) sowohl mit der Quicksort als auch mit der
    standardmäßigen Sortierung im Vergleich sehr schlecht abschneidet.
    Darauf folgt die standardmäßige Sortierung in Java (3).
    Diese ist überraschenderweise langsamer als meine Quicksort Implementation in Java (5).
    Zwischen diesen beiden liegt meine Quicksort in Javascript.
    Darauf folgt dann Julia (6), wo meine eigene Quicksort fast genauso schnell war wie
    die standardmäßige Sortierfunktion.
    Einzig schneller sind nur die standardmäßige Sortierfunktion in Javascript (7) und meine
    Quicksort Implementation in Go (8). Diese ist allerdings nur bedingt vergleichbar, da ich
    aufgrund von beschriebenen Schwierigkeiten nur 7 Millionen Zahlen sortieren konnte.
    Meine Go-Variante lässt sich also nicht als schnellste Version bezeichnen.

    \end{multicols}
}

\block{C++ Radixsort Implementationen}{
    \begin{multicols}{2}

    \Large
    In den vorigen Teilen ging es um die Optimierung der Quicksort. Dieser Abschnitt
    behandelt die Radixsort, ist also nicht mit den Ergebnissen und Überlegungen von davor vergleichbar.
    Es wurden hier nicht nur Optimierungen, sondern auch andere Algorithmen genutzt.
    Der Grund warum ich mich auch mit der Radixsort beschäftigte ist, dass ich
    den schnellsten Weg zur Sortierung von 10 Millionen Zufallszahlen finden wollte.
    Die Quicksort hat eine durchschnittliche Komplexität von \boldmath$O(n\log n)$,
    die Radixsort von \boldmath$O(n \cdot w)$. Die Radixsort ist also algorithmisch gesehen schneller.
    Meine erste Implementation der Radixsort (1) brauchte 2.269 Sekunden. Sie war damit
    also langsamer als viele der Versionen der Quicksort aus den vorigen Diagrammen.
    Meine weiteren Implementationen (2, 3) mithilfe der Artikel von Pierre Terdimann und
    Michael Herf waren dann allerdings deutlich schneller als alle Vorigen der Quicksort Versionen.
    Dies zeigte mir, dass die korrekte Implementation von Algorithmen eine Rolle spielt,
    da meine erste Version zwar einen überlegenden Algorithmus nutzte, aber trotzdem
    langsamer war. Auch zeigte sich, dass bei korrekter Implementation die Wahl des
    Algorithmus sehr wichtig ist. Bei meinen besten Versionen der Radixsort und der Quicksort
    war erstere deutlich schneller. Daraus schloss ich, dass vor der Optimierung der
    Implementation am besten erst der beste bekannte Algorithmus gewählt werden sollte.
    Ich fragte mich, wieso die Radixsort nicht häufiger benutzt wird, was ich mir leider nicht
    beantworten konnte.
    
    \columnbreak

    \begin{tikzfigure}[]
        \begin{bchart}[min=0, max=2.5, scale=4]
            \bcbar[label=1, text=Radixsort mit Basis 10 (Countingsort)]{2.269}
            \smallskip
            \bcbar[label=2, text=\hspace{7cm}Radixsort mit Basis 256 (Bytesort)]{0.244}
            \smallskip
            \bcbar[label=3, text=\hspace{7cm}Radixsort mit Basis 256 (Bytesort) und AVX2]{0.240}
            \smallskip
            \bcxlabel{\bf{Ausführungszeit in Sekunden}}
        \end{bchart}
    \end{tikzfigure}

    \end{multicols}
}

\end{document}
